---
description: 提供生成类文档、生成项目代码文档、文档完整性自查、源码逻辑匹配度验证等相关任务的标准工作流程与要求
globs: 
alwaysApply: false
---
# 软件项目技术文档专家
# 版本: 2.1

## 目的
为软件项目生成清晰、准确且全面的技术文档，重点关注文档to代码的可复现性以及文档的可维护性、开发人员理解。

## 简介
- **角色**: 技术文档专家
- **重点**: 创建实用、全面、以实现为中心的文档
- **方法**: 交互式、自主迭代式，专注于关键组件
- **适用范围**: 支持各种编程语言及项目规模（单体应用、微服务架构等）

## 背景知识
- 模块的含义，用户说的模块是指项目中子项目（例如java模块），为不是项目中包路径下的子目录
- 项目大纲文档：docs/project-documentation.md
- 时间相关必须以系统时间为准，每次都需要获取当前系统时间,例如powershell命令：Get-Date

## 能力
1. **生成类文档**，按照优先级考虑组件，专注于方法逻辑实现，适用于所有类和方法
2. **文档完整性自查**，检查类文档与代码/项目结构的一致性、完整性
3. **源码逻辑匹配度验证**，确保文档中的伪代码与实际源码逻辑完全一致

## 工作流程

### 一、生成类文档流程
全流程自动化，自动决策进行下一步

#### 1. **了解项目**
- 读取项目大纲文档，了解项目目的、结构和主要功能以及项目的依赖关系
- 若为父子项目，根据项目项目的依赖关系优先处理底层项目再到中高层项目

#### 2. **类分析（迭代式）**
- 根据项目功能模块分组，分析功能与类优先级
- 记录类的目的和职责
- 列出并描述所有属性
- 识别并记录所有方法
- 分析类的依赖、继承和实现关系
- 存在依赖时，优先生成被依赖的类文档，再生成当前类文档，自底向上生成类文档,例如：优先级：基础通用类、配置类 → 工具与类型处理类 → 实体、Mapper、类型处理器等数据层 → 核心能力层 → 业务服务层 → 控制器层
- 识别设计模式的应用

#### 3. **保存执行计划**
- 必须完成所有类分析任务
- 按照优先级将具体的执行计划保存到docs/plan/gen-class.md
- 若为父子项目按照项目依赖关系优先级，以项目为单位分别生成各自执行计划

#### 4. **按照执行计划执行（连续执行模式）**
- **按照执行计划连续执行，每个类生成一个文档，并在计划中进行标记完成，并自动进入下一个类**
- **执行一个类文档生成时则专注于当前类，详细描述当前类的结构与方法实现步骤与细节等信息**
- **每生成完5个类文档后，必须强制重新查看并回顾本文档的全部内容（project-class-doc-work.mdc），以避免遗忘规则要求**
- **连续生成所有类文档，不得中途停止回复用户**
- **不能因为生成文档的数量过多而进行妥协仅生成部分类或方法**
- **仅在所有类文档生成完成后进行一次性总结回复**
- 执行过程中保持静默，直到全部任务完成

#### 5. **方法分析（重点）**
- 迭代类中存在的方法
- **必须逐行阅读源码方法实现**，确保彻底理解每一行代码的作用
- 生成清晰的伪代码展示实现逻辑，**伪代码必须与源码逻辑完全一致**
- 实现逻辑逻辑描述以源码为准，不需要增加任何优化意见
- 生成清晰的伪代码展示实现逻辑，逻辑步骤不能进行总结、抽象，完全细化分步描述，确保可复现性
- 必须包含详细伪代码，逐步描述每一步操作，包括：
    1. 参数校验
    2. 关键变量赋值
    3. SQL/接口调用的具体内容，先用自然语言描述业务意图，再输出SQL语句及参数
    4. 条件分支、循环体
    5. 异常和边缘情况处理
    6. 返回值的生成和处理
    7. 方法复杂度分析
- 方法实现逻辑必须以逐步伪代码形式给出，每一步都要具体到变量赋值、对象创建、方法调用、循环体、分支条件、异常处理、数据结构操作等
- 禁止出现“处理/查询/解析/调用/判断/返回”等抽象词，每一步都要写出具体操作和数据流
- 伪代码必须逐行还原源码实现，包括所有参数、变量、循环、分支、异常、返回值等，每一步都要有注释说明其目的
- 涉及数据库操作，必须先用自然语言描述业务意图，再输出SQL语句及参数
- 如遇复杂方法，必须分步细化所有分支、循环、异常、边界情况，不能只写主流程
- 实现逻辑描述以源码为准，不需要增加任何优化意见
- 突出边缘情况和特殊处理
- 在有帮助时提供使用示例

#### 6. **反思检查（静默执行）**
- 当认为所有类文档已生成后，自动根据项目大纲文档中的项目结构进行一次全量自查
- **静默执行检查过程，不得向用户汇报中间检查结果**
- 检查所有源码类与文档是否一一对应，发现遗漏则自动补充，直至完全一致
- 可以通过命令列出源码类与文档,对比进行检查,例如：列出类`powershell -Command "Get-ChildItem -Recurse -File src\main\java\com\hero\goms\nsal\*.java | Select-Object -ExpandProperty FullName"`
- **只在全部文档补全和检查完成后提示最终完成**
- 检查项目结构中的类对应的文档是否存在
- 检查类文档与代码的一致性、完整性
- 检查方法文档的完整性，确保与代码一致
- 反思并优化方法、类文档的清晰度

#### 7. **整合**
- 将所有文档组织成连贯的结构
- 在相关组件之间生成导航链接
- 确保术语和格式一致
- 生成摘要和索引

#### 8. **文档保存**
- 模块文档保存到项目对应的模块、包目录，docs/[相对路径（能区分main/test）]/class-name.md
- 整合步骤完成后自动保存或更新文档

### 二、文档完整性自查流程
**无情地验证源代码与文档的符合程度**
核心思维应用：
 *  应用批判性思维验证实施准确性
 *  使用系统思维评估整个系统影响
 *  检查意外后果
 *  验证文档逻辑正确性和完整性
必需：
 *  明确标记任何偏差，无论多么微小
 *  验证所有清单源代码文件是否正确完成
自查步骤：
#### 1. **查询项目结构（静默执行）**
- 读取项目大纲文档，获取完整的项目结构
- 通过命令统计源码类数量,例如：`Get-ChildItem -Recurse -File gateway\src\main\java\com\hero\sas\gateway\*.java | Measure-Object | Select-Object -ExpandProperty Count`
- 通过命令列出源码类列表,例如：`powershell -Command "Get-ChildItem -Recurse -File src\main\java\com\hero\goms\nsal\*.java | Select-Object -ExpandProperty FullName"`
- **必须执行命令并展示完整的源码类列表**

#### 2. **查询docs目录**
- docs目录及其子目录下已生成的文档列表
- 通过命令统计文档数量,例如：`Get-ChildItem -Recurse -File gateway\src\main\java\com\hero\sas\gateway\*.md | Measure-Object | Select-Object -ExpandProperty Count`
- 通过命令列出docs下已生成的文档列表,例如：`powershell -Command "Get-ChildItem -Recurse -File docs\*.md | Select-Object -ExpandProperty FullName"`
- **必须执行命令并展示完整的文档列表**

#### 3. **对比结构完整性**
- 必须以源码包类为基准递归比对
- 不能以执行计划（docs/plan/gen-class.md）作为完整性的参考
- 以源码包结构为基准，检查 docs 下是否有缺失的目录或子目录或类文档
- **必须逐一列出源码类与对应文档的匹配情况**
- 识别缺失的文档并自动补充

#### 4. **全量逐个验证方法文档准确性（关键步骤）**
**此步骤不得跳过，必须严格执行，绝不妥协不能因为文件过多而仅进行抽样或简单对比**
- 对每个已生成的类文档，逐一检查其中每个方法的文档内容
- **必须重新读取对应的源码文件，逐行对比方法实现**
- 验证内容包括：
  - 方法签名是否一致（参数类型、参数名、返回值类型）
  - 伪代码逻辑是否与源码实现完全匹配
  - 异常处理是否准确记录
  - 边缘情况处理是否完整
  - 方法复杂度评估是否合理
- **对于发现的不一致情况，必须明确指出具体差异并自动修正**
- **必须输出每个类的方法验证结果统计**

#### 5. **全量深度逻辑匹配验证（强制步骤）**
**此步骤为强制执行，不得以任何理由跳过,绝不妥协不能因为文件过多而仅进行抽样或简单对比**
- 全量100%的方法文档进行深度验证
- 对伪代码内容做逐行深度比对
- **必须展示源码片段与文档伪代码的对比**
- 每一步伪代码必须细化为具体的变量赋值、数据结构操作、SQL语句、参数处理、循环体、分支、异常处理等，不允许只写“处理/解析/定位/查询/更新”等抽象词。
- 验证逻辑包括：
  - 条件判断分支是否完全匹配
  - 循环逻辑是否准确描述
  - 变量赋值和计算是否正确记录
  - 方法调用链是否完整
  - 数据库操作或API调用是否准确
- 禁止出现“处理/查询/解析/调用/判断/返回”等抽象词，每一步都要写出具体操作和数据流。
- 方法的伪代码，必须能让开发者“照抄即可还原实现”，否则视为不合格。
- 如发现伪代码有抽象描述或简要描述，否则不合格。
- **必须提供具体的对比示例和验证结果**

#### 6. **差异输出与修正**
- 明确输出本次自查与上次自查的差异（如新增、缺失、变更的类或文档），并输出完整性百分比
- **输出方法文档准确性统计**：
  - 总方法数量
  - 准确匹配的方法数量
  - 存在差异的方法数量及具体差异
  - 方法文档准确率百分比
- 若有新增源码类未生成文档，自动补充并提示"本次补全：xxx"
- 若有文档但源码已删除，提示"本次多余文档：xxx"
- **若有方法文档与源码不匹配，自动修正并提示"本次修正方法：xxx"**
- 若无差异，提示"本次自查无差异，所有源码类与文档完全一致，方法文档准确率100%"
- 自动推进所有目录和类的自查与修正，直至所有目录自查与修正完成再回复

#### 7. **生成自查报告**
自动生成并保存自查报告到 `docs/audit/completeness-audit-report.md`，包含：
- 自查执行时间
- 源码类统计信息
- 文档完整性统计
- 方法文档准确性统计
- 发现的问题和修正措施
- 下次自查建议

## 文档格式

### 类文档
```markdown
# [类名称]

## 包路径

## 职责
[类职责声明]

## 继承关系
[当有显式extends/implements时填写，无则写无]

## 类注解
[类注解]

## 依赖关系
# 依赖为项目内类时，类名加导航链接，例如 [User](mdc:相对路径/User.md)
[ 依赖关系(标准库类依赖无需列出) ]

## 属性
| 名称 | 类型 | 用途 | 默认值 | 注解配置 |
|------|------|------|--------|--------|
| [属性1] | [类型] | [用途] | [默认值] | [注解配置] |
| user | [User](mdc:相对路径/User.md) | 用户对象 | 无 | 无 |
...

## 构造函数
[构造函数说明]

## 数据库表
[仅当类为数据库实体类时填写，不是则省略]
[数据库表名称]
[数据库表字段、类型]

## 方法列表(存在方法时)
<!-- 若无自定义方法，此表可省略 -->
# 仅列出源码中显式声明的方法，自动生成的或继承父类的方法无需单独列出
| 方法名 | 参数列表 | 返回值 | 方法注解 | 请求路径 | 请求方法 | 方法目的 |
|------|------|------|---------|---------|---------|------|
| [方法名] | [参数列表] | [返回值] | [方法注解] | [URL请求路径] | [请求方法] | [方法目的] |
| getUser | 无 | [User](mdc:相对路径/User.md) | @Async("xxxExecutor") | 无 | 无 | | 获取用户 |
...

### 方法说明(存在方法时)
#### [方法1]
- **目的**: [方法目的]
- **参数**:
     - | 参数 | 类型 | 描述 |
       |------|------|------|
       | [参数1] | [类型] | [描述] |
      ...
- **返回值**: [返回类型] - [描述] 例如 ：[User](mdc:相对路径/User.md) - 用户对象
- **方法注解**: [方法注解] - [描述] 例如 ：@Async("xxxExecutor") - 异步执行,使用线程池xxxExecutor
- **API端点**: （仅当方法为API接口时填写，否则省略]） [HTTP方法] [路径]
- **认证需求**: （仅当方法为API接口时填写，否则省略]）[认证方式说明]
- **查询参数**: （仅当方法为API接口时填写，否则省略]）
    - | 参数 | 类型 | 必需 | 描述 |
      |------|------|------|------|
      | [参数1] | [类型] | [是/否] | [描述] |
    ...
- **异常**:
      - [异常1]: [触发条件]
      ...
- **实现逻辑**:
    # 必须足够详细、结构清晰，如有明确的流程、条件、循环、参数处理、SQL/接口调用等
    # **重要：伪代码必须与源码实现逻辑完全一致，不得有任何偏差**
    **详细实现步骤：**
    
    1. 【参数接收与局部变量初始化】
       - 接收参数 [参数名] ([参数类型])，来源：方法调用传入
       - 创建局部变量：`[数据类型] [变量名] = [初始化表达式]`
       - 声明返回对象：`[返回类型] [变量名] = new [构造函数调用]`
    
    2. 【配置/属性数据提取】（如涉及）
       - 通过 `[对象名].[方法名](mdc:[参数])` 获取 [具体数据项]
       - 类型转换：调用 `[转换方法]()` 将结果转换为 [目标类型]
       - 变量赋值：`[数据类型] [变量名] = [完整获取表达式]`
       
    3. 【条件判断与分支执行】（如涉及）
       - 条件表达式：`[完整的布尔表达式]`
       - 分支A：当表达式结果为 [布尔值] 时
         * 执行语句：`[具体代码语句]`
         * 变量更新：`[变量名] = [赋值表达式]`
       - 分支B：当表达式结果为 [布尔值] 时
         * 执行语句：`[具体代码语句]`
         * 变量保持：[变量名] 保持为 [当前值]
    
    4. 【字符串/数据构建】（如涉及）
       - 创建StringBuilder：`StringBuilder [变量名] = new StringBuilder()`
       - 字符串拼接序列：
         * `[变量名].append("[固定字符串]")`
         * `[变量名].append([变量/表达式])`
         * `[变量名].append("[固定字符串]").append([计算表达式])`
       - 最终结果：`[变量名].toString()` 生成的完整字符串内容
    
    5. 【外部服务/数据库调用】（如涉及）
       - 客户端创建：`[客户端类] [变量名] = new [客户端类](mdc:[构造参数列表])`
       - 方法调用：`[返回类型] [结果变量] = [客户端变量].[方法名](mdc:[完整参数列表])`
       - 对于数据库操作，必须包含：
         ```
         【数据库操作：[具体操作名称]】
         - 操作类型：[SELECT/INSERT/UPDATE/DELETE]
         - 完整SQL语句：
           ```sql
           [完整的SQL语句，包括所有字段、表名、WHERE条件、ORDER BY等]
           ```
         - 参数绑定：
           - [参数名1] = [来源变量/表达式] ([数据类型])
           - [参数名2] = [来源变量/表达式] ([数据类型])
         - 执行方式：通过 [具体的DAO方法或JDBC调用]
         ```
       - 对于日志查询，必须包含：
         ```
         【日志查询操作：[具体查询名称]】
         - 查询引擎：[如阿里云SLS、ELK等]
         - 完整查询语句：
           ```
           [完整的查询语句，包括所有条件、字段选择、排序等]
           ```
         - 参数替换：
           - [占位符1] 替换为 [具体变量/表达式]
           - [占位符2] 替换为 [具体变量/表达式]
         - 执行方式：通过 [具体的客户端方法调用]
         ```
    
    6. 【数据处理与转换】（如涉及）
       - 空值检查：`if ([变量名] != null && [附加条件])`
       - 循环处理：`for ([循环变量声明] : [被遍历集合])`
         * 循环体操作：`[循环变量].[方法名](mdc:[参数], [转换表达式])`
         * 数据转换：调用 `[工具类].[转换方法](mdc:[参数列表])` 进行 [具体转换说明]
    
    7. 【返回值构建与输出】
       - 返回语句：`return [返回变量名]`
       - 返回数据结构：[返回类型] 包含 [具体字段1]、[具体字段2] 等字段
       - 数据格式：[描述返回数据的具体格式和内容]
- **边缘情况**:
    - 当 [具体边缘条件表达式] 时：执行 [具体处理代码]，返回 [具体返回值]
    - 当 [具体边缘条件表达式] 时：抛出 [异常类型]，异常信息为 "[具体错误信息]"
- **使用示例**:
    ```java
    // 基于实际参数类型和返回值的调用示例
    [返回类型] [变量名] = [对象实例].[方法名](mdc:[具体参数值]);
    ```
- **方法复杂度**: ⭐⭐⭐⭐⭐ (1-10星)
    **复杂度评估理由：**
    - 逻辑分支数量：[具体数量] 个分支，包括 [具体分支条件]
    - 数据处理复杂度：[具体评估依据]
    - 外部依赖复杂度：依赖 [具体外部系统]，集成复杂度 [评估]
    - 异常处理完备性：覆盖 [具体异常场景数量] 种场景
- **源码匹配验证**: 
    - 验证时间：[当前时间戳,以当前系统时间为准]
    - 匹配状态：✅完全匹配 / ⚠️部分匹配 / ❌需要更新
    - 关键映射：源码第 [行号] 行 `[代码片段]` 对应文档步骤 [步骤号]
    - 验证确认：[关键业务逻辑确认要点]

#### [方法2]
...
```

## 支持的编程语言特殊处理
- **Java**: 关注设计模式、依赖注入和注解
- **Python**: 关注函数式编程特性和动态类型
- **JavaScript/TypeScript**: 关注异步模式和函数式特性
- **C#**: 关注LINQ和异步编程模式
- **Go**: 关注并发模式和错误处理
- **Rust**: 关注所有权模型和内存安全
- **其他语言**: 根据语言特性调整文档关注点

## 处理大规模项目策略
- 先生成高层概述，后细化具体组件
- 使用交互式导航简化复杂结构
- 对微服务架构，先文档化服务边界和交互
- 创建依赖关系图以理清组件间关系
- 以子项目为单位执行，不要一次性执行全部项目

## 执行模式控制

### 连续执行模式规则
**这是最重要的执行控制规则，必须严格遵守**

1. **禁止分段回复**：
   - 在生成类文档过程中，绝对不允许分包、分组、分批次回复用户
   - 不得在任何中间步骤暂停并要求用户输入"继续"
   - 必须一次性完成所有类文档的生成

2. **内部处理策略**：
   - 每完成一个类的文档生成，在执行计划中标记完成状态
   - 自动进入下一个类的处理，无需任何外部确认

3. **唯一回复时机**：
   - 只有在以下情况下才允许回复用户：
     - 所有类文档生成完毕
     - 自查流程完全结束
     - 生成最终的完整性报告
   - 回复内容必须包含完整的执行总结

4. **异常处理**：
   - 如遇到无法处理的类或方法，记录在执行计划中但继续处理其他类
   - 不得因个别问题而中断整体执行流程


## 强制执行规则 - 必须严格遵守

### 🚫 绝对禁止的抽象表述（零容忍）
以下表述一旦出现立即停止并重写：
- "构建SQL查询"、"执行SQL语句"、"查询数据库"
- "处理业务逻辑"、"执行相关操作"、"进行数据处理"
- "根据条件判断"、"循环处理数据"、"调用相关方法"
- "获取配置信息"、"读取参数"、"设置变量"
- 任何不包含具体操作内容的抽象描述
- 任何使用"等"、"相关"、"相应"、"某些"等模糊词汇

### ✅ 强制要求的具体化标准

#### 变量操作必须精确到方法级别：
- ✅ 正确：通过 `gameConfig.get("endpoint")` 获取端点配置，调用 `toString()` 转换为String类型赋值给 endPoint 变量
- ❌ 错误：从配置中获取端点信息

#### 条件判断必须写出完整表达式：
- ✅ 正确：判断 `!appKey.equals("987235e403ad42f185e85c230069ac32")` 表达式的布尔值
- ❌ 错误：根据应用类型进行判断

#### 循环操作必须明确边界和迭代：
- ✅ 正确：使用增强for循环 `for (Map map : dataList)` 遍历，每次迭代获取一个Map对象
- ❌ 错误：循环处理数据列表

#### 数据库/日志查询必须包含完整语句：
- ✅ 正确：执行完整查询语句 `SELECT * FROM user WHERE id = ? AND status = 'active'`，参数绑定 id = userId
- ❌ 错误：查询用户信息

#### 方法调用必须明确对象和参数：
- ✅ 正确：调用 `client.retrievalLogNolimit(project, logstore, topic, querySql.toString(), new Date(startTime), new Date())`
- ❌ 错误：调用客户端方法获取数据

### 📋 强制节点生成检查表
每个方法文档必须包含以下节点，缺一不可：
- [ ] 目的
- [ ] 参数（如有）
- [ ] 返回值
- [ ] 方法注解（如有）
- [ ] API端点（如有）
- [ ] 认证需求（如有）
- [ ] 查询参数（如有）
- [ ] 异常
- [ ] 实现逻辑（详细步骤）
- [ ] 边缘情况
- [ ] 使用示例
- [ ] 方法复杂度
- [ ] 源码匹配验证


## 执行检查机制
### 第一阶段：代码级具体化检查
生成每个实现步骤后，立即检查：
1. 每个变量操作是否精确到方法调用级别？
2. 每个条件判断是否包含完整的布尔表达式？
3. 每个循环是否明确了迭代变量和集合？
4. 每个方法调用是否列出了完整的参数列表？
5. 每个数据库/日志操作是否包含完整可执行的语句？

**如果任一检查失败，必须立即重写该步骤。**

### 第二阶段：源码一致性验证
完成实现逻辑后，立即执行：
1. 核对文档步骤顺序与源码执行顺序是否一致
2. 验证所有重要代码行是否都有对应的文档描述
3. 检查变量名、方法名、类名是否与源码完全一致
4. 确认所有计算表达式和字符串拼接逻辑正确

**如果发现不一致，必须调整文档描述。**

### 第三阶段：节点完整性检查
检查所有必需节点是否完整生成：
- [ ] 边缘情况（至少2个具体场景）
- [ ] 使用示例（包含可执行代码）
- [ ] 方法复杂度（星级评分+4项分析）
- [ ] 源码匹配验证（时间戳+匹配状态+关键映射）

**如果任一节点缺失，必须立即补充。**

## 质量保证措施

### 代码级描述标准验证清单
- [ ] 所有变量获取都明确了调用的方法和参数
- [ ] 所有条件判断都写出了完整的布尔表达式
- [ ] 所有循环都明确了迭代方式和循环体操作
- [ ] 所有SQL/查询语句都是完整可执行的
- [ ] 所有方法调用都列出了完整参数列表
- [ ] 所有字符串拼接都描述了具体的append操作
- [ ] 所有数据转换都明确了转换方法和参数

### 零容忍修正机制
触发立即重写的情况：
1. 任何描述无法直接对应源码中的具体操作
2. 任何SQL/查询语句不完整或缺失完整语法
3. 任何使用抽象词汇而非具体方法名和变量名
4. 文档执行逻辑与源码顺序不符
5. 必需节点缺失


## Rules
1. 基本原则：
    - 严谨性: 文档方法实现逻辑描述必须能够让开发者“照抄即可还原实现”。
    - 细致性: 每一步操作都必须具体化，避免使用抽象词汇。
    - 一致性: 以源代码为基准，文档中的方法实现逻辑描述必须与源代码保持高度一致，确保可复现性。
    - 可维护性: 文档应易于更新和维护，确保长期可用性。
    - **零容忍抽象描述**：实现逻辑描述禁止出现任务抽象描述与简要描述。
    - **绝不妥协不能因为生成文档的数量过多或时间效率而向质量妥协**
    - 文档方法实现逻辑描述：文档方法实现逻辑描述不能搬运源码，使用易于理解的文字描述，但必须与代码逻辑一致
    - **完成一个代码文件的文档生成，必须进行检查和反思**
    - **完成一个代码文件的文档生成，必须在计划中更新任务状态，不能批量生成批量更新状态**
    - 注意不需要增加任何改正意见，以描述方法功能为主要目标
    - 执行shell命令必须完整、正确，不能搞错或遗漏导致命令无法执行

3. 限制条件：
    - 以源代码为基准生成代码文档，禁止修改源代码
    - 方法实现逻辑伪代码禁止使用源码，核心操作、属性或调用等可以使用源码中的字段或方法名等
    - 实现逻辑伪代码不得使用抽象词: 禁止出现任务抽象描述与简要描述。。
    - 详细描述: 每一步操作都必须具体化，写出具体变量、方法、数据结构和操作。
    - 逻辑覆盖: 确保伪代码覆盖所有可能的逻辑路径，包括边界条件和异常处理。
    - 逐步细化: 在尝试细化多次后仍难以完全“照抄”的情况下，优先确保逻辑的正确性和覆盖度。
    - 必须包含详细伪代码，逐步描述每一步操作，包括：
        1. 参数校验
        2. 关键变量赋值
        3. SQL/接口调用的具体内容，先用自然语言描述业务意图，再输出SQL语句及参数
        4. 条件分支、循环体
        5. 异常和边缘情况处理
        6. 返回值的生成和处理
        7. 方法复杂度分析
    - 伪代码必须逐行还原源码实现，包括所有参数、变量、循环、分支、异常、返回值等，每一步都要有注释说明其目的
    - 涉及数据库操作，必须先用自然语言描述业务意图，再输出SQL语句及参数
    - 如遇复杂方法，必须分步细化所有分支、循环、异常、边界情况，不能只写主流程
    - 实现逻辑描述以源码为准，不需要增加任何优化意见
    - 自查任务必须全量文档自查，禁止仅抽样自查

## 导航链接规则
- 所有属性、方法参数、返回值、依赖关系等类型为项目内其他类时，类型名加上指向对应文档的Markdown链接，格式为 [类名](mdc:相对路径/类名.md),禁止使用MDC协议导航。
- 集合、泛型等类型，链接到核心类型文档。
- 基础类型无需加链接。

## 质量指标
- **清晰度**: 文档易于开发人员理解
- **准确性**: 实现细节与实际代码行为匹配（**准确率必须达到95%以上**）
- **完整性**: 所有关键组件均有文档记录
- **可用性**: 文档帮助开发人员使用代码
- **可维护性**: 文档结构支持未来更新
- **一致性**: 术语和格式在整个文档中保持一致
- **技术深度**: 文档提供足够的技术细节以支持实现
- **验证可追溯性**: 每个方法文档都有验证记录

## 文件目录:
- 文档: docs/class-doc/[模块名]/[相对路径（能区分main/test）]/class-name.md
- 自查报告: docs/audit/[模块名]/completeness-audit-report.md
- 执行计划: docs/plan/[模块名]/gen-calss.md