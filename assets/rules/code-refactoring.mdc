---
description: 提供代码重构、优化等相关任务执行规则与要求
globs: 
alwaysApply: false
---
# 代码重构优化

## 项目文档
- 项目大纲文档：docs/project-documentation.md
- 类文档位置：docs/**/**.md

## 核心约束 (CRITICAL CONSTRAINTS)
- 🚫 NEVER破坏现有功能和业务逻辑
- 🚫 NEVER修改对外API接口地址、参数、响应格式
- 🚫 NEVER改变接口行为和状态码
- 🚫 NEVER使用脚本修改代码文件
- 🚫 NEVER过度设计，平衡改动量与设计的权重，提供适合项目的重构方案
- ✅ ALWAYS 保持向后兼容性,避免大量修改代码、破坏已有功能逻辑
- ✅ ALWAYS 评估跨模块影响范围
- ✅ ALWAYS 绝不主动修改已有表结构字段、表名，仅有用户明确提出可以变动表结构字段、表名才能修改
- ✅ ALWAYS 充分利用主流技术与第三方库，避免无意义的编码与重复轮子
- ✅ ALWAYS 不能轻易删除原有代码，仅当确定原有代码逻辑已完成迁移或者新代码已实现现有逻辑才能删除原有代码
- ✅ ALWAYS 所有代码修改必须经过深度思考,确保修改后的代码不会造成功能缺失、重复代码
- ✅ ALWAYS 每个步骤执行你必须深入思考分析是否造成功能缺失与逻辑缺失
- ✅ ALWAYS 每个步骤执行完成后使用GIT命令提交，保持多次提交用于追踪与回滚，并同步更新步骤执行状态

## 重构目标
- 提升代码可读性、可维护性、可测试性
- 优化架构设计，降低耦合度，提高内聚性
- 消除代码异味和重复代码
- 在保持功能不变的前提下优化性能
- **构建清晰的模块边界和职责划分**
- 保持表结构字段、表关系简洁稳定

## 重构原则
### 代码质量
- 遵循SOLID原则
- 应用DRY、KISS、YAGNI原则
- 使用合适的设计模式
- 保持代码简洁明了

### 架构设计
- 清晰的模块分层架构（common-service-app-startup）
- 清晰的职责分层架构（Controller-Service-Repository）
- 模块化设计，高内聚低耦合
- 依赖注入和控制反转
- 配置与代码分离
- **领域驱动设计(DDD)边界上下文**

### 大型项目特殊原则
- **模块自治性**：每个模块能独立开发、测试、部署
- **接口稳定性**：模块间通过稳定接口通信
- **版本兼容性**：支持渐进式升级
- **故障隔离**：单模块故障不影响整体系统

## 模块创建决策框架

### 何时创建新模块
```
IF (满足以下任一条件) THEN 考虑创建新模块：

1. **职责边界判断**
   - 现有类承担多个不相关的业务职责
   - 代码修改经常涉及多个不同的业务概念
   - 团队成员对某个类的职责理解不一致

2. **依赖关系复杂度**
   - 出现循环依赖且难以通过简单重构解决
   - 某个包的依赖关系图呈现高度复杂的网状结构
   - 修改一个类需要同时修改多个不相关的类

3. **代码规模阈值**
   - 单个包的类数量超过20个
   - 单个类的行数超过500行且职责无法进一步分解
   - 单个方法超过50行且逻辑复杂

4. **业务独立性**
   - 某些功能具有独立的业务生命周期
   - 功能可以被多个不同的上下文使用
   - 具有独立的数据模型和业务规则

5. **团队组织结构**
   - 不同团队负责的功能混在同一个模块中
   - 功能的发布周期和节奏差异很大
   - 需要不同的技术栈或性能要求
```

### 新模块创建指南

#### 1. 模块命名规范
```java
// 好的模块命名示例
com.company.project.user        // 用户管理
com.company.project.order       // 订单处理  
com.company.project.payment     // 支付服务
com.company.project.notification // 通知服务

// 避免的命名
com.company.project.util        // 过于通用
com.company.project.common      // 职责不明确
com.company.project.helper      // 含义模糊
```

#### 2. 模块结构模板
```
新模块标准结构：
src/main/java/com/company/project/[module-name]/
├── api/           # 对外接口定义
├── domain/        # 领域模型和业务逻辑
├── infrastructure/ # 基础设施层
├── application/   # 应用服务层
└── config/        # 模块配置
```

#### 3. 模块接口设计
```java
// 模块接口示例
public interface UserService {
    // 明确的输入输出类型
    UserDto getUserById(Long userId);
    
    // 异常处理清晰
    UserDto createUser(CreateUserRequest request) throws UserCreationException;
    
    // 批量操作支持
    List<UserDto> getUsersByIds(List<Long> userIds);
}
```

## 重构步骤（大型项目版）

### 1. **全局架构分析**
- 绘制模块依赖图
- 识别架构热点和瓶颈
- 评估现有模块的内聚性和耦合度
- 分析跨模块的数据流和调用链

### 2. **业务领域建模**
- 识别核心业务概念和边界
- 划分限界上下文(Bounded Context)
- 定义聚合根和实体关系
- 明确模块间的业务依赖关系

### 3. **重构优先级排序**
```
优先级评估矩阵：
High Priority = High Business Impact + Low Technical Risk
- 核心业务流程优化
- 性能瓶颈解决
- 安全漏洞修复

Medium Priority = Medium Business Impact + Medium Technical Risk  
- 代码质量改善
- 架构简化
- 开发效率提升

Low Priority = Low Business Impact + High Technical Risk
- 技术债务清理
- 非关键功能重构
- 实验性优化
```

### 4. **渐进式重构执行**
- **阶段1**：架构设计模块拆分，保持旧接口兼容
- **阶段2**：生成单元测试、数据MOCK测试，验证已有功能是否被破坏
- **阶段3**：模块/子项目内部代码优化、重构，不改变模块接口
- **阶段4**：生成单元测试、数据MOCK测试，验证已有功能是否被破坏
- **阶段5**：接口迁移，逐步废弃旧接口
- **阶段6**：生成单元测试与接口测试、数据MOCK测试，验证已有功能是否被破坏
- **阶段7**：清理遗留代码

#### 逆向工程验证方法论
对于多表操作的复杂方法（如syncPermission），采用以下验证流程：

1. **深度源码分析**
   - 逐行分析旧方法源码
   - 识别所有数据库操作步骤
   - 记录字段设置规则和固定值
   - 梳理业务逻辑分支和异常处理

2. **详细逻辑文档生成**
   - 按阶段划分方法执行流程
   - 记录每个步骤的具体操作和参数
   - 标注关键业务规则和约束条件
   - 明确数据表操作类型和次数

3. **新方法功能对比验证**
   - 逐步骤对比新旧方法实现
   - 验证数据字段设置的一致性
   - 确认业务逻辑分支的完整性
   - 识别任何功能缺失或差异

#### 分层测试验证策略

1. **Mock测试层**
   - 验证Feature开关机制
   - 确认方法调用路由正确
   - 测试参数传递完整性
   - 验证边界条件处理

2. **数据库验证层**
   - 验证多表数据操作一致性
   - 确认关联关系建立正确
   - 测试数据操作的幂等性
   - 验证事务处理机制

3. **生产数据验证层**
   - 通过MCP工具查询实际数据
   - 验证业务规则的实际应用
   - 确认数据量级和性能特征
   - 分析真实使用场景

#### 功能缺失处理流程

当发现新方法功能缺失时：

1. **问题识别和分析**
   - 准确描述缺失的功能逻辑
   - 分析缺失功能的业务影响
   - 确定触发条件和使用场景

2. **修复实施**
   - 在新方法中补充缺失逻辑
   - 保持与旧方法完全一致的实现
   - 集成到正确的执行位置

3. **修复验证**
   - 重新运行所有测试用例
   - 验证修复效果的正确性
   - 确认无引入新的问题

#### 验证工具清单

1. **代码分析工具**
   - codebase_search：语义搜索相关代码
   - grep_search：精确匹配特定模式
   - read_file：详细阅读源码实现

2. **数据库验证工具**
   - MySQL MCP：查询生产数据库状态
   - 测试数据库：验证数据操作效果
   - 事务回滚测试：确保测试环境清洁

3. **文档生成工具**
   - 逻辑分析文档：记录旧方法完整逻辑
   - 对比验证文档：逐步验证功能一致性
   - 最终验证报告：总结验证结果和建议

## 代码规范

### 模块/子项目级规范
- **依赖方向**：上层模块可依赖下层，同层模块通过接口通信
- **循环依赖**：严禁任何形式的循环依赖
- **接口稳定性**：公共接口变更需要版本管理
- **异常处理**：模块间异常传递需要明确定义

### 跨模块通信规范
```java
// 推荐：通过接口通信
@Service
public class OrderService {
    private final UserService userService;  // 依赖接口
    private final PaymentService paymentService;
}

// 避免：直接依赖实现类
@Service  
public class OrderService {
    private final UserServiceImpl userService;  // 依赖具体实现
}
```

## 大型项目重构模式

### 1. 绞杀者模式 (Strangler Fig)
```java
// 新旧系统并存的适配器
@Component
public class LegacyUserServiceAdapter implements UserService {
    private final LegacyUserService legacyService;
    private final NewUserService newService;
    
    @Value("${feature.new-user-service.enabled:false}")
    private boolean useNewService;
    
    public UserDto getUserById(Long userId) {
        return useNewService ? 
            newService.getUserById(userId) : 
            legacyService.getUserById(userId);
    }
}
```

### 2. 防腐层模式 (Anti-Corruption Layer)
```java
// 外部系统接口适配
@Component
public class ExternalPaymentAdapter {
    private final ExternalPaymentClient client;
    
    public PaymentResult processPayment(PaymentRequest request) {
        // 转换内部模型到外部接口格式
        ExternalPaymentRequest externalRequest = convertToExternal(request);
        ExternalPaymentResponse response = client.pay(externalRequest);
        // 转换外部响应到内部模型
        return convertToInternal(response);
    }
}
```

### 3. 事件驱动解耦
```java
// 模块间通过事件通信
@EventListener
public class OrderEventHandler {
    private final InventoryService inventoryService;
    
    @Async
    public void handleOrderCreated(OrderCreatedEvent event) {
        inventoryService.reserveItems(event.getOrderItems());
    }
}
```

## 自主分析指导原则

### AI辅助决策规则
```
WHEN 分析项目时，自动检查：
1. **项目职责分析**
   - 分析项目类型
   - 分析各子项目职责与边界
   - 分析子项目间的依赖关系

2. **依赖关系分析** 
   - 绘制项目级别的依赖图
   - 评估依赖的稳定性

WHEN 分析代码时，自动检查：

1. **类职责分析**
   - 统计类的公共方法数量和类型
   - 分析方法间的相关性
   - 识别数据和行为的匹配度

2. **依赖关系分析** 
   - 绘制包级别的依赖图
   - 计算循环依赖的数量和复杂度
   - 评估依赖的稳定性

3. **业务概念提取**
   - 从类名、方法名中提取业务概念
   - 分析相似概念的聚合可能性
   - 识别横切关注点

4. **模块边界建议**
   基于以上分析，当满足以下条件时建议创建新模块：
   - 识别出3个以上相关的业务概念
   - 存在明确的数据边界
   - 具有独立的业务规则
   - 可以定义稳定的接口
```

## 质量保证清单

### 重构前检查
- [ ] 梳理完整的模块依赖关系
- [ ] 识别所有公共接口和调用方
- [ ] 准备回滚方案和数据备份
- [ ] 制定详细的测试计划

### 重构中验证
- [ ] 每次变更后运行完整测试套件
- [ ] 验证跨模块集成功能正常
- [ ] 监控系统性能指标
- [ ] 检查新模块的接口设计合理性

### 重构后确认
- [ ] 所有原有功能正常工作
- [ ] 新模块职责边界清晰
- [ ] 减少了模块间的不必要耦合
- [ ] 提升了代码的可维护性
- [ ] 团队对新架构理解一致

## 风险控制

### 技术风险
- **数据一致性**：跨模块数据操作的事务处理
- **性能影响**：模块拆分可能带来的性能损耗
- **集成复杂度**：新模块与现有系统的集成成本

### 组织风险  
- **团队协调**：跨团队的重构协调成本
- **知识传递**：架构变更的知识分享和培训
- **发布协调**：多模块协同发布的复杂度

### 缓解策略
- 建立架构决策记录(ADR)
- 定期进行架构审查
- 建立模块间的契约测试
- 实施蓝绿部署和灰度发布
- 建立监控和告警机制

## 成功指标

### 技术指标
- 模块间耦合度降低 > 30%
- 代码重复率降低 > 50%  
- 单元测试覆盖率提升 > 20%
- 构建和测试时间优化 > 25%

### 业务指标
- 功能开发效率提升 > 40%
- 故障定位时间缩短 > 60%
- 新人上手时间减少 > 50%
- 生产故障数量下降 > 30%

### 功能完整性要求（100%标准）

- **逻辑一致性**：新方法必须100%复现旧方法的所有逻辑分支
- **数据操作一致性**：所有数据库操作的表、字段、约束必须完全一致
- **业务规则一致性**：字段设置规则、固定值、命名规则必须完全一致
- **异常处理一致性**：事务边界、回滚机制、错误处理必须完全一致
- **性能特征一致性**：数据库交互次数和模式必须基本一致

### 验证文档要求

每次方法验证必须生成以下文档：

1. **逻辑分析文档**（`legacy-{方法名}-logic-analysis.md`）
   - 完整的旧方法逻辑梳理
   - 分阶段的执行流程描述
   - 数据库操作的详细记录

2. **功能验证文档**（`new-{方法名}-logic-verification.md`）
   - 新旧方法的逐步对比
   - 功能一致性验证结果
   - 问题发现和修复记录

3. **最终验证报告**（`{方法名}-verification-final-report.md`）
   - 验证过程的完整记录
   - 测试结果的统计分析
   - 生产切换的风险评估和建议

## 标准工作流程
1. 研究模式，项目分析，父子项目优先进行单个子项目优化
2. 研究模式，代码分析，充分的理解代码功能与目标
3. 研究模式，输出详细重构方案文档refactoring-optimization-summ.md、具体重构计划文档refactoring-optimization-plan.md，保存至项目下docs/refactoring/[子项目名]/目录下
   - 重构方案分版本分阶段，优先项目结构化优化（若需要）-> 公共模块抽取明确业务边界（若需要） -> 巨型类优化拆分 -> 内部复杂业务方法逻辑优化 -> 基础框架架构优化
   - 优先项目架构评估设计和模块边界重构,必要时划分maven模块，但不能缺失功能
   - 内部代码逻辑优化重构,优先巨型类拆分,对外部接口不允许修改,不能缺失功能
   - 禁止调整实体类对象字段、增加数据库表
   - 按照方法业务优先级进行排序
   - 方案执行计划步骤必须详细，必须具体到类方法单位的，输出方案必须是进行反思深度思考之后的结果
   - 执行计划中每个步骤必须为单个类或方法的优化方案，以类或方法作为最小单元
   - 充分利用Context7 MCP查询主流技术与第三方库文档，避免无意义的编码与重复轮子
   - 优先使用Lombok注解简化模型对象set/get方法
4. 执行模式，按照优化方案文档逐步优化，并同步更新已完成的步骤优化点
   - 分阶段重构，每次只修改一个小模块
   - 编译验证，每个修改后立即编译验证
   - 渐进式替换，保持新旧API并存，逐步迁移
   - 充分测试，确保每个阶段功能完整
   - 优化完成后必须进行单元测试、数据准确性测试、集成测试、功能测试、边界测试，单独使用数据库MCP查询数据并验证，确保功能正常
   - 只有所有测试通过后,才能认为当前步骤完成，并标记为已完成
   - 修复发现的问题时,不能直接修改代码，应优先读取代码文档,确定并理解原有功能并根据当前问题进行分析,确保修改不会影响原有功能,并且修改合理,然后进行修复
   - 每个步骤执行完成后使用GIT命令提交，保持多次提交用于追踪与回滚，并同步更新步骤执行状态
5. 审查模式，严格审查优化的方法或类功能逻辑是否与原服务类方法逻辑一致，确保无功能、逻辑缺失，无简化TODO实现
6. 执行模式，根据审查报告修复发现的问题；修复完成回退至步骤5再次审查，直到再次审查无问题后进入下一步
7. 执行模式，同步更新docs/class-doc/目录下的代码文档内容
8. 执行模式，编写完整充分的单元测试、数据准确性测试，覆盖所有设计变动的功能，必须每个阶段都进行独立测试，所有步骤完成后再进行一次全面测试
9. 执行模式，修复测试问题，并同步代码文档内容

### 复杂方法测试策略
对于涉及多表操作的方法：
1. **不使用@Rollback注解进行真实数据持久化测试**
2. **通过数据库MCP工具进行实际数据验证**
3. **创建专门的数据一致性验证测试类**
4. **实施幂等性测试确保重复调用安全**
5. **进行并发安全性和性能影响评估**
6. **若多模块项目单元测是优先编写在启动类所有在模块下**
7. **按照功能业务流程优先级逐个测试，禁止一次性编写多个测试方法，按照编写一个测试一个策略**
8. **优先分析现有的单元测试进行调整完成测试**
9. **禁止通过删除代码文件消除错误**

## 执行约束
- 围绕重构目标持续推进，每阶段完成后必须再次查看重构要求与规则
- 自主分析决策执行，不需要向用户选择或询问是否需要执行（YES/NO）
- 必要时使用context7 MCP获取最新技术站或第三方库文档进行学习
- 修改代码时不能直接进行修改代码，应优先读取相关文档确定原有功能,并反思修改内容是否合理
- mvn命令不能限制超时时间
- 必须经常回顾查看重构规范与要求文档,确保重构修改内容符合要求
- 所有临时生成的文件都放到对应子项目下/temp/ 目录下
- 启动测试时，当需要使用maven环境配置时默认使用dev或test
- 输出所有报告必须真实，必须诚实地报告，不能假设或捏造
- 所有测试不允许使用预定返回值，必须使用真实数据，并通过你单独使用数据库MCP查询数据进行最终验证
- 测试用户禁止使用admin用户名测试，必须通过自行创建用户测试
- 使用数据库MCP时，不能搞错表名，必须通过实体类注解进行确认
- 一个类的单元测试都保持一个测试类中，一个类的不同方法不允许创建多个测试类
- 禁止通过删除代码文件或片段解决编译错误，必须深入分析代码真正解决错误问题
- 内部优化时优先保持原方法或类，通过新建方法或类进行优化处理，完成充分测试后可适当移除原方法或类